#
#  Project: ByoDyn
#
#  Copyright (C) 2008 Alex Gomez-Garrido, Adrian L. Garcia-Lomana and Jordi Villa-Freixa
#
#  Author: Alex Gomez-Garrido and Adrian L. Garcia-Lomana
#
#  Created: 2007-12-11 by Alex Gomez-Garrido
#
#  This application is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
#  This application is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Library General Public License for more details.
#
#  You should have received a copy of the GNU General Public
#  License along with this library; if not, write to the Free
#  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
# 

# $Id: simulatorEuler.py,v 4.5 2008/12/16 21:35:06 alglomana Exp $

## \file 
# This module is responsible of the numerical integrations functions and the Euler method.

import os, re, sys, copy
import formulas, initiator, errorMessages, sbmlWorker
from affectors import *
try:
    import matplotlib.pyplot
except ImportError:
    raise errorMessages.ClassSimulatorEulerException, 'error while importing matplotlib.pyplot.'
     
class ClassSimulatorEuler:

    '''
    Class for the Euler simulator.
    '''    

    def __init__(self):

        '''
        The constructor.
        '''
        
        return None

    def run(self, metamodel, model, outputfiles):

        '''
	This method directs the simulation.
	It creates the initial conditions, 
	loads the system of equations, 
	integrates the system and
	plots the results.
        '''

        variables, initialVariablesValues = self.__getVariables(model)
        self.__writeTopologyInput(model, outputfiles, initialVariablesValues, variables)
        func = self.__loadIntegrationFunction(outputfiles)
        x, t = self.integrate(func, initialVariablesValues, metamodel.simulationTime, metamodel.simulationTimeStep)
	self.__storeResults(x, t, model, metamodel, outputfiles)
	if metamodel.graphics == True:
	    self.__plotSimulation(x, t, model, metamodel, outputfiles)
        
    def integrate(self, f, x_0, time, dt):
	
	'''
	This method integrates the system of equations.
	'''

        t = [0.0]
        x = []
        x.append(x_0)
    
        for n in range(int(time/dt)+1):
            t.append(t[n] + dt)
            xdot = f(x[n])
            x.append([])
            for i in range(len(x[n])):
                x[n+1].append(x[n][i] + dt*xdot[i])

        return x, t

    def __getVariables(self, model):
	
	'''
	This private method sets the initial conditions of the system.
	'''

        #/ 1.- dealing with initial conditions
        variables = []
        initialVariablesValues = []
        for n in model.nodes:
            if model.constantNodes.keys().count(n) == 0:
                variables.append(n)
                initialVariablesValues.append(model.initialConditions[model.nodes.index(n)])
        for n in model.algebraicNodes:
            variables.append(n)
            initialVariablesValues.append(model.algebraicNodes[n])
        for n in model.nonConstantParameters:
            variables.append(n)
            initialVariablesValues.append(model.nonConstantParameters[n])
        for n in model.nonConstantCompartments:
            variables.append(n) 
            initialVariablesValues.append(model.nonConstantCompartments[n])   
        #/ 2.- in the case of a multicellular system
        if model.xlength != 1 or model.ywidth != 1:
            initialVariablesValues = model.initialConditions
        
        return variables, initialVariablesValues


    def __writeTopologyInput(self, model, outputfiles, initialVariablesValues, variables):
	
	'''
	This private method writes a file with the topology of the system.
	'''
	
	#/ 1.- Writting some headers
        file = open(outputfiles.integrationInput, 'w')
        file.write('#/\n#/ generated by ByoDyn version %s\n#/\nimport scipy\nfrom scipy.integrate import odeint\nimport math\nfrom scipy import exp\nfrom scipy import sqrt\nfrom scipy import ceil\nfrom scipy import sin\nfrom scipy import pi\n'%initiator.BYODYNVERSION)
        #/ 2.- Writting sbml defined functions
        for function in model.functions:
            file.write('def %s(' %(function.id))
            file.write('%s' %function.arguments[0])
            for argument in function.arguments[1:]:
                file.write(', %s' %argument)
            file.write('):\n')    
            squareRootDefinitions = re.findall('root\(2, [\w\[\]()/\+\-\*\s\d\.\^\,]*\)', function.output)
            if len(squareRootDefinitions) != 0:
                function.output = function.output.replace('root(2, ', 'sqrt(')
            file.write('\treturn %s\n' %function.output)
        #/ 3.- Starting the function
        file.write('def func(x):\n')
	#/ 4.- Defining required variables
        option = 'python'
        cellIndex = 0 
        equationNumber = 0
	#/ 5.- Parameters, compartments and constant nodes
        for parameter in model.parameters.keys():
            file.write('\t%s = %s\n'%(parameter, model.parameters[parameter]))
        for compartment in model.compartments.keys():
            file.write('\t%s = %s\n'%(compartment, model.compartments[compartment]['size']))
        for specie in model.constantNodes.keys():
            file.write('\t%s = %s\n'%(specie, model.constantNodes[specie]))
	#/ 6.- Defining the topology
        file.write('\txdot = [0.0')
        for i in range(len(initialVariablesValues)-1):
            file.write(', 0.0')
        file.write(']\n')
        for i in range (model.xlength):
            for j in range (model.ywidth):
                for node in variables:
                    file.write('\txdot[%s] = ' %(equationNumber))
                    equationNumber = equationNumber + 1               
                    first = 0
                    for definition in model.topology.keys():
                        fieldsDefinition = definition.split('/')
                        if fieldsDefinition[0] == node:
                            exec "%s(model, file, option, cellIndex, definition, fieldsDefinition)"%fieldsDefinition[1]
                            first = 1
                    if first == 0:
                        file.write('0')
                    file.write('\n')
                cellIndex = cellIndex + 1
        file.write('\treturn xdot\n')
        file.close()
        
	return self

    def __loadIntegrationFunction(self, outputfiles):

	'''
	This private method loads the system of equations, that is the topology of the system.
	'''

        sys.path.append('%s' %outputfiles.scratchdir)
        import integrationFunction
        from integrationFunction import func

        return func

    def __plotSimulation(self, x, t, model, metamodel, outputfiles):
        
        '''
	This private method creates the graph of the trajectories.
	'''
        
	#/ 1.- Inverting the matrix of trajectories.
        var = []
        for j in range(len(x)):
            for i in range(len(x[j])):
                if j == 0:
                    var.append([x[j][i]])
                else:
                    var[i].append(x[j][i])
        #/ 2.- Setting names
        matplotlib.pyplot.xlabel('Time') #/ set x-axis label
        matplotlib.pyplot.ylabel('Concentration') #/ set y-axis label
        matplotlib.pyplot.title(model.systemName) #/ set plot title
        #/ 3.- plotting variables
        for variable in var:
            matplotlib.pyplot.plot(t, variable, '.')
        matplotlib.pyplot.legend(model.nodes)
        #/ 4.- Saving figure or displaying the figure
	if metamodel.showingPlot == True:
	    matplotlib.pyplot.show()
	else:
	    matplotlib.pyplot.savefig(outputfiles.timePlot,dpi=1200)

	return None

    def __storeResults(self, x, t, model, metamodel, outputfiles):

	'''
	This method stores the results of the simulation in a file in the output directory.
	'''
	
	#/ 0.- Inverting the matrix of trajectories.
        var = []
        for j in range(len(x)):
            for i in range(len(x[j])):
                if j == 0:
                    var.append([x[j][i]])
                else:
                    var[i].append(x[j][i])
	#/ 1.- writing the headers
	file = open(outputfiles.simulationResults, 'w')
	file.write('#\n# generated by ByoDyn version %s\n#\n'%initiator.BYODYNVERSION)
	#/ 2.- writing the trajectories
	for i in range(len(t)):
	    file.write('%s\t'%t[i])
	    for variable in var:
		file.write('%s\t'%variable[i])
	    file.write('\n')		       
	file.close()

	return None
        
