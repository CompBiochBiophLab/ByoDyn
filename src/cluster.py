#
#  Project: ByoDyn
#
#  Copyright (C) 2008 Adrian L. Garcia-Lomana & Jordi Villa-Freixa
#
#  Author: Adrian L. Garcia-Lomana and Alex Gomez-Garrido
#
#  Created: 2008-07-11 by Adrian L. Garcia-Lomana
#
#  This application is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
#  This application is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Library General Public License for more details.
#
#  You should have received a copy of the GNU General Public
#  License along with this library; if not, write to the Free
#  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
# 

# $Id: cluster.py,v 4.11 2008/12/14 19:27:52 alglomana Exp $

## \file 
# This module is responsible for clustering.
# The method used is mean shift.
# We used a matlab implementation from Bryan Feldman.

import sys, math, os, scipy
import initiator
try:
    import matplotlib.pyplot
except ImportError:
    raise errorMessages.ClassSimulatorStochasticException, 'error while importing matplotlib.pyplot.'

def dataTransformer(metamodel, outputfiles):

    '''
    This function converts the data points to the adequate scale.
    '''
    
    #/ 1.- reading the file
    f = open(metamodel.clusterInputData, 'r')
    data = f.readlines()
    f.close()
    #/ 2.- determining the scales
    scales = []
    labels = []
    for datum in data:
	if datum[0] == '#':
	    vector = datum.split()
	    if len(vector) > 1:
		for element in vector:
		    if element.find('(log)') > 0:
			scales.append('log')
			labels.append('log ' + element.split('(log)')[0])
		    if element.find('(lin)') > 0:
			scales.append('lin')
			labels.append(element.split('(lin)')[0])
    #/ 3.- saving the data
    f = open(outputfiles.clusterScaledInputData, 'w')
    message = '#\n# generated by ByoDyn version ' + initiator.BYODYNVERSION + '\n#\n# this is the scaled data file for the clustering.\n#\n'
    f.write(message)
    for datum in data:
	if datum[0] != '#':
	    vector = datum.split()
	    vector.pop()
	    for i in range(len(vector)):
		if scales[i] == 'log':
		    f.write('%s\t'%math.log10(float(vector[i])))
		else:
		    f.write('%s\t'%vector[i])
	    f.write('\n')			
    f.close()

    return len(scales), labels

def defaultRunner(clusteringRange, metamodel, outputfiles):
    
    '''
    This function runs the clustering for the defined range of resolution values.
    '''
    
    for i in range(len(clusteringRange)):
	#/ defining values
	metamodel.bandwidth = clusteringRange[i]
	currentDirectory = outputfiles.scratchdir + '/resolution_' + str(clusteringRange[i])
	os.mkdir(currentDirectory)
	outputfiles.clusterResultsTextFile = currentDirectory + '/' + 'clusterResults.txt'
	outputfiles.clusterCentersTextFile = currentDirectory + '/' + 'clusterCenters.txt'
	outputfiles.clusterCode = currentDirectory + '/' + 'clusteringCode.m'
	#/ calling the appropriate functions
	octaveCodeWriter(metamodel, outputfiles)
	octaveExecuter(outputfiles)

    return None

def main(metamodel, outputfiles):

    '''
    This is the main function for the cluster algorithm.
    This function directs the flow of algorithm.
    '''
    
    if metamodel.bandwidth == 'default':
	clusteringRange = resolutionChecker(metamodel, outputfiles)
	defaultRunner(clusteringRange, metamodel, outputfiles)
    else:
	dimension, labels = dataTransformer(metamodel, outputfiles)
	if dimension == 1:
	    raise errorMessages.ClassClusterException, 'there is currently no support for clustering on one dimension. Sorry for the inconvenience.'        
	octaveCodeWriter(metamodel, outputfiles)
	octaveExecuter(outputfiles)
	plotter(outputfiles, dimension, labels)

    return None

def octaveCodeWriter(metamodel, outputfiles):

    '''
    This function writes the a simple code of octave to call the clustering algorithm.
    '''

    #/ 1.- retrieving path dirs
    directory = os.environ.get('BYODYN_PATH')
    directory = directory + '/lib/clustering/'
    #/ 2.- writing the code file
    f = open(outputfiles.clusterCode, 'w')
    message = '%\n% generated by ByoDyn version ' + initiator.BYODYNVERSION + '\n%\n% this is the code file for clustering using octave\n%\n'
    f.write(message)
    f.write('close all\n')
    f.write('clear\n')
    f.write('addpath("%s")\n'%directory)
    f.write('load -ascii %s;\n'%outputfiles.clusterScaledInputData)
    f.write('bandwidth = %s;\n'%metamodel.bandwidth)
    f.write("x = clusterScaledInputData';\n") #/ very important the ' for matrix dimensions
    f.write('[clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(x,bandwidth);\n') 
    f.write('fid = fopen ("%s", "w");\n'%outputfiles.clusterResultsTextFile)
    f.write('fprintf(fid,"#\\n# generated by ByoDyn version %s\\n#\\n# here are stored the position of each of the points with its corresponding label indicating the cluster they belong to (first column)\\n#\\n")\n'%initiator.BYODYNVERSION)
    f.write('for k = 1:length(clustMembsCell)\n')
    f.write('\tclusterMembers = clustMembsCell{k};\n')
    f.write('\tfor m = 1:length(clusterMembers)\n')
    f.write('\t\tfprintf(fid,"%i\\t",k);\n')
    f.write('\t\tfor n = 1:size(x)\n')
    f.write('\t\t\tfprintf(fid,"%e\\t",x(n,clusterMembers(m)));\n')
    f.write('\t\tend\n')
    f.write('\t\tfprintf(fid,"\\n");\n')
    f.write('\tend\n')
    f.write('end\n')
    f.write('fclose(fid);\n')
    f.write('fid = fopen("%s", "w");\n'%outputfiles.clusterCentersTextFile)
    f.write('fprintf(fid,"#\\n# generated by ByoDyn version %s\\n#\\n# here are stored the position of the centers of each cluster\\n#\\n")\n'%initiator.BYODYNVERSION)
    f.write('for k = 1:length(clustMembsCell)\n')
    f.write('\tfor n = 1:size(x)\n')
    f.write('\t\tfprintf(fid,"%e\\t",clustCent(n,k))\n')
    f.write('\tend\n')
    f.write('\tfprintf(fid,"\\n");\n')
    f.write('end\n')
    f.write('fclose(fid);\n')
    f.write('exit')
    f.close()

    return None

def octaveExecuter(outputfiles):
    
    '''
    This function executes the octave code for clustering.
    '''

    os.system('octave -q %s' %(outputfiles.clusterCode))

    return None

def plotter(outputfiles, dimension, labels):

    '''
    This function plots the results of the clustering.
    '''
    
    if dimension == 2:
	print 'Picturing a surface ...'
	surfacePlotter(outputfiles, labels)
    if dimension == 3:
	print 'Picturing a volume ...'
	volumePlotter(outputfiles, labels)
    if dimension > 3:
	print 'The number of dimensions is more than 3 and therefore no plot is created.'

    return None

def resolutionChecker(metamodel, outputfiles):
    
    '''
    This function defines different resolution bandwidths and run the clustering for each value.
    The results are analysed
    '''

    #/ 1.- transforming the data
    dimension, labels = dataTransformer(metamodel, outputfiles)
    if dimension == 1:
	raise errorMessages.ClassClusterException, 'there is currently no support for clustering on one dimension. Sorry for the inconvenience.' 
    #/ 1.- determining the ranges
    ranges = []
    values = []
    for d in range(dimension):
	values.append([])
    f = open(outputfiles.clusterScaledInputData, 'r')
    data = f.readlines()
    f.close()
    #/ 1.1.- reading the data
    for datum in data:
	if datum[0] != '#':
	    vector = datum.split()
	    for i in range(len(vector)):
		values[i].append(float(vector[i]))
    for i in range(dimension):
	ranges.append(max(values[i]) - min(values[i]))
    #/ 2.- clustering ranges
    pointsRange = [min(ranges)/20.,max(ranges)] #/ from the largest dimension to 20 times smaller than the smaller dimension
    clusteringRange = scipy.arange(pointsRange[0], pointsRange[1], (pointsRange[1]-pointsRange[0])/20.) #/ 20 points on the  range for the resolution.

    return clusteringRange

def surfacePlotter(outputfiles, labels):
    
    '''
    This function creates a plot of the clusters in 2D. Based on sampler.plot2D
    '''
    
    x = []
    y = []
    centersX = []
    centersY = []
    colours = []
    #/ 1.- reading the data
    #/ 1.1.- for the points
    f = open(outputfiles.clusterResultsTextFile, 'r')
    data = f.readlines()
    f.close()
    for datum in data:
	if datum[0] != '#':
	    vector = datum.split()
	    colours.append(int(vector[0]))
	    x.append(float(vector[1]))
	    y.append(float(vector[2]))
    #/ 1.2.- for the centers
    f = open(outputfiles.clusterCentersTextFile, 'r')
    data = f.readlines()
    f.close()
    for datum in data:
	if datum[0] != '#':
	    vector = datum.split()
	    centersX.append(float(vector[0]))
	    centersY.append(float(vector[1]))
    #/ 2.- plotting
    matplotlib.pyplot.scatter(x,y,s=.015,c=colours,linewidths=0)
    centerColours = []
    for colour in colours:
	if centerColours.count(colour) == 0:
	    centerColours.append(colour)
    matplotlib.pyplot.scatter(centersX,centersY,s=.25,c=centerColours)
    matplotlib.pyplot.xlabel(labels[0])
    matplotlib.pyplot.ylabel(labels[1])
    matplotlib.pyplot.title('Sample Distribution')
    matplotlib.pyplot.savefig(outputfiles.clusterResultsFigure,dpi=1200)
    
    return None

def volumePlotter(outputfiles, labels):
    
    '''
    This function creates a plot of the clusters in 3D. Based on sampler.plot3D
    '''
    
    #/ 1.- reading required data
    centersX = []; centersY = []; centersZ = []
    #/ 1.1.- reading the centers
    f = open(outputfiles.clusterCentersTextFile, 'r')
    data = f.readlines()
    f.close()
    for datum in data:
	if datum[0] != '#':
	    vector = datum.split()
	    centersX.append(float(vector[0]))
	    centersY.append(float(vector[1]))
	    centersZ.append(float(vector[2]))
    #/ 1.2.- converting to the appropriate format the centers data file for plotting
    f = open(outputfiles.scratchdir + '/clusterCentersPlottingFormat.txt', 'w')
    f.write('#\n# generated by ByoDyn version %s\n# this file contains the position of the clusters centers and their corresponding label they belong to\n#\n'%initiator.BYODYNVERSION)
    count  = 0
    for i in range(len(data)):
	if data[i][0] != '#':
	    count = count + 1
	    vector = data[i].split()
	    vector.append(str(count))
	    for element in vector:
		f.write('%s\t'%element)
	    f.write('\n')
    f.close()
    #/2.- creating the gnuplot file
    f = open(outputfiles.scratchdir + '/clusteringPlot.3D.gnu', 'w')
    f.write('#\n# generated by ByoDyn version %s\n#\n# gnuplot commands to create a 3D figure of the clusters\n#\n'%initiator.BYODYNVERSION)
    f.write('set term postscript color\n')
    f.write('set output "%s"\n'%outputfiles.clusterResultsFigure)
    f.write('set nokey\n')
    f.write('set pointsize .2\n')
    f.write('set xtics border out scale 2,2 mirror norotate offset character 0, -.5, 0\n')
    f.write('set ytics border out scale 2,2 mirror norotate offset character 0, -.5, 0\n')
    f.write('set title "Cluster Distribution"\n')
    f.write('set xlabel "%s"\n'%labels[0])
    f.write('set ylabel "%s"\n'%labels[1])
    f.write('set zlabel "%s"\n'%labels[2])
    f.write('unset colorbox\n')
    #/ 2.1.- defining available colors: 
    availableColours = ['red', 'blue', 'green', 'yellow', 'orange', 'purple', 'cyan', 'magenta', 'turquoise', 'pink', 'coral', 'aquamarine', 'brown', 'plum', 'dark-red', 'light-red', 'dark-green', 'light-green', 'dark-blue', 'light-blue']
    while len(availableColours) < len(centersX):
	availableColours = availableColours + availableColours
    f.write('set palette defined (1 "red"')
    for i in range(len(centersX)-1):
	f.write(', %s "%s"'%(i+2,availableColours[i+2]))
    f.write(')\n')
    f.write('splot "%s" u 2:3:4:1  w points palette pt 7, "%s" u 1:2:3:4 w points palette pt 7 pointsize 1\n'%(outputfiles.clusterResultsTextFile,outputfiles.scratchdir + '/clusterCentersPlottingFormat.txt'))
    f.close()
    #/ 3.- calling the gnuplot
    os.system('gnuplot 2> %s %s'%(outputfiles.scratchdir + '/clusteringPlot.3D.gnu.error.message.txt',outputfiles.scratchdir + '/clusteringPlot.3D.gnu'))
    
    return None
