#
#  Project: ByoDyn
#
#  Copyright (C) 2008 Adrian L. Garcia-Lomana & Jordi Villa-Freixa
#
#  Author: Adrian L. Garcia-Lomana and Alex Gomez-Garrido
#
#  Created: 2004-10-06 by Adrian L. Garcia-Lomana
#
#  This application is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
#  This application is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Library General Public License for more details.
#
#  You should have received a copy of the GNU General Public
#  License along with this library; if not, write to the Free
#  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
# 

# $Id: centralFunctions.py,v 4.5 2008/12/03 16:37:38 alglomana Exp $

## \file
# This module holds the central functions of the program.
# By central functions we mean functions that may be required by either during the simulation, the sensitivity analysis or the optimisation.

import sys, os, copy, re
import formulas, parallel, initiator #/ the module "formulas" is in the lib directory
from affectors import *

def callingOctave(outputfiles):
    
    ''' 
    This function calls Octave to integrate the system of equations of the model. 
    The system has been written in a file with the Octave format. 
    '''
    
    os.system('octave -q %s' %(outputfiles.octaveInputFile))

    return None

def callingPython(outputfiles):
    
    ''' 
    This function calls Python to integrate the system of equations of the model.
    The system has been written in a file with Python format. 
    '''

    os.system('python %s' %(outputfiles.pythonIntegrationFile))

    return None

def createInputOctave(metamodel, model, outputfiles):

    '''
    This function creates the input file for the Octave integration. 
    '''

    option = 'octave'
    cellIndex = 0
    equationNumber = 1 #/ octave starts numbering the equation after 1, not after 0.
    daesSystem = False
    octave = open(outputfiles.octaveInputFile, 'w')
    octave.write('#\n# generated by ByoDyn version %s\n#\n# this is the input file for octave\n#\n'%initiator.BYODYNVERSION)
    #/ Adding pow function, so we don't need translate powers in octave format
    octave.write('function value = pow(x, y)\n')
    octave.write('\tvalue = x**y;\n')
    octave.write('endfunction\n')
    #/ writting sbml defined functions
    for function in model.functions:
        octave.write('function result = %s(' %(function.id))
        octave.write('%s' %function.arguments[0])
        for argument in function.arguments[1:]:
            octave.write(', %s' %argument)
        octave.write(')\n')    
        squareRootDefinitions = re.findall('root\(2, [\w\[\]()/\+\-\*\s\d\.\^\,]*\)', function.output)
        if len(squareRootDefinitions) != 0:
            function.output = function.output.replace('root(2, ', 'sqrt(')
        octave.write('\tresult = %s;\n' %function.output)
        octave.write('endfunction\n')
    #/ If the model have assignment rules or algebraic rules, the system is a DAEs system and we use the DASPK function, else we use LSODE
    for rule in model.rules:   
        if rule.type == 'Assignment' or rule.type == 'Algebraic':
            daesSystem = True
    if daesSystem == True:
        octave.write('function res = f (x, xdot, t)\n')
        writeParametersOctave(model, octave)
        octave.write('#\n# these are the differential equations used on the run\n#\n') # writting equations
        for i in range (model.xlength):
            for j in range (model.ywidth):
                for node in model.nodes:
                    if model.constantNodes.keys().count(node) == 0:
                        octave.write('res(%s) = - xdot(%s) ' %(equationNumber, equationNumber))
                        equationNumber = equationNumber + 1
                    writeFormulaOctave(model, node, octave, option, cellIndex)
                for node in model.algebraicNodes:
                    for rule in model.rules:
                        if rule.variable == node:
                            if rule.type == 'Rate':   
                                octave.write('res(%s) = - xdot(%s) + ' %(equationNumber, equationNumber))
                                equationNumber = equationNumber + 1
                                writeFormulaOctave(model, rule.variable, octave, option, cellIndex) 
                            if rule.type == 'Algebraic':
                                octave.write('res(%s) = ' %(equationNumber)) 
                                formulas.readWriteFormula(model, octave, cellIndex, 'octave', rule.math)
                                octave.write(';\n')    
                                equationNumber = equationNumber + 1
                            if rule.type == 'Assignment':
                                octave.write('res(%s) = ' %(equationNumber))
                                formula = '- %s + %s' %(rule.variable, rule.math)
                                formulas.readWriteFormula(model, octave, cellIndex, 'octave', formula)
                                octave.write(';\n')
                                equationNumber = equationNumber + 1                                                         
                for node in model.nonConstantParameters:
                    for rule in model.rules:
                        if rule.variable == node:
                            if rule.type == 'Rate':   
                                octave.write('res(%s) = - xdot(%s) + ' %(equationNumber, equationNumber))
                                equationNumber = equationNumber + 1
                                writeFormulaOctave(model, rule.variable, octave, option, cellIndex) 
                            if rule.type == 'Algebraic':
                                octave.write('res(%s) = ' %(equationNumber)) 
                                formulas.readWriteFormula(model, octave, cellIndex, 'octave', rule.math)
                                octave.write(';\n')    
                                equationNumber = equationNumber + 1
                            if rule.type == 'Assignment':
                                octave.write('res(%s) = ' %(equationNumber))
                                formula = '- %s + %s' %(rule.variable, rule.math)
                                formulas.readWriteFormula(model, octave, cellIndex, 'octave', formula)
                                octave.write(';\n')
                                equationNumber = equationNumber + 1  
                for node in model.nonConstantCompartments:
                    for rule in model.rules:
                        if rule.variable == node:
                            if rule.type == 'Rate': 
                                octave.write('res(%s) = - xdot(%s) + ' %(equationNumber, equationNumber))
                                equationNumber = equationNumber + 1
                                writeFormulaOctave(model, rule.variable, octave, option, cellIndex) 
                            if rule.type == 'Algebraic':
                                octave.write('res(%s) = ' %(equationNumber)) 
                                formulas.readWriteFormula(model, octave, cellIndex, 'octave', rule.math)
                                octave.write(';\n')    
                                equationNumber = equationNumber + 1
                            if rule.type == 'Assignment':
                                octave.write('res(%s) = ' %(equationNumber))
                                formula = '- %s + %s' %(rule.variable, rule.math)
                                formulas.readWriteFormula(model, octave, cellIndex, 'octave', formula)
                                octave.write(';\n')
                                equationNumber = equationNumber + 1                                                         
                cellIndex = cellIndex + 1                
        octave.write('endfunction\n')
        #/ writing the initial conditions
        writeInitialConditionsOctave(model, metamodel, octave, 'daspk')    
        if metamodel.integrationMethod != 'default' and metamodel.integrationOption == 'octave':# defining the integration method for Octave
            octave.write('daspk_options ("integration method", "%s");\n' %(metamodel.integrationMethod)) #/ the "_" cannot be removed because is the required format from octave
        octave.write('[x, xdot] = daspk ("f", x0, xdot0, t);\n') # this is the critical step for solving the ODEs
    else:
        octave.write('function xdot = f (x, t)\n')
        writeParametersOctave(model, octave)
        octave.write('#\n# these are the differential equations used on the run\n#\n') # writting equations
        for i in range (model.xlength):
            for j in range (model.ywidth):
                for node in model.nodes:
                    if model.constantNodes.keys().count(node) == 0:
                        octave.write('xdot(%s) = ' %(equationNumber))
                        equationNumber = equationNumber + 1
                        writeFormulaOctave(model, node, octave, option, cellIndex)
                for node in model.algebraicNodes:
                    for rule in model.rules:
                        if rule.variable == node:
			    if rule.type == 'Rate':
				octave.write('xdot(%s) = ' %(equationNumber))                                        
				equationNumber = equationNumber + 1
				writeFormulaOctave(model, rule.variable, octave, option, cellIndex)                      
                for node in model.nonConstantParameters:
                    for rule in model.rules:
                        if rule.variable == node:
			    if rule.type == 'Rate':
				octave.write('xdot(%s) = ' %(equationNumber))                                        
				equationNumber = equationNumber + 1
				writeFormulaOctave(model, rule.variable, octave, option, cellIndex)      
                for node in model.nonConstantCompartments:
		    for rule in model.rules:
			if rule.type == 'Rate':
			    if rule.variable == node:
				octave.write('xdot(%s) = ' %(equationNumber))                                        
				equationNumber = equationNumber + 1
				writeFormulaOctave(model, rule.variable, octave, option, cellIndex)              
                cellIndex = cellIndex + 1
        octave.write('endfunction\n')
        #/ writing the initial conditions
        writeInitialConditionsOctave(model, metamodel, octave, 'lsode')  
        if metamodel.integrationMethod != 'default' and metamodel.integrationOption == 'octave':#/ defining the integration method for Octave
            octave.write('lsode_options ("integration method", "%s");\n' %(metamodel.integrationMethod)) #/ the "_" cannot be removed because is the required format from octave           
        octave.write('x = lsode ("f", x0, t);\n') #/ this is the critical step for solving the ODEs
    #/ saving data of the simulation into files ...
    octave.write('save %s t;\n' %(outputfiles.octaveIntegrationTime))
    octave.write('save %s x;\n' %(outputfiles.octaveIntegrationData))
    octave.write('exit\n')
    octave.close()

    return None

def createInputPython(metamodel, model, outputfiles):

    ''' 
    This function creates the input file for the Python integration. 
    '''

    #/ 1.- initializing some variables
    option = 'python'
    cellIndex = 0 
    equationNumber = 0
    args = []
    #/ 1.2.- dealing with initial conditions
    variables = []
    initialVariablesValues = []
    for n in model.nodes:
        if model.constantNodes.keys().count(n) == 0:
            variables.append(n)
            initialVariablesValues.append(model.initialConditions[model.nodes.index(n)])
    for n in model.algebraicNodes:
        variables.append(n)
        initialVariablesValues.append(model.algebraicNodes[n])
    for n in model.nonConstantParameters:
        variables.append(n)
        initialVariablesValues.append(model.nonConstantParameters[n])
    for n in model.nonConstantCompartments:
        variables.append(n) 
        initialVariablesValues.append(model.nonConstantCompartments[n])   
    #/ in the case of a multicellular system
    if model.xlength != 1 or model.ywidth != 1:
        initialVariablesValues = model.initialConditions
    #/ 2.- writting the file
    #/ PARALLEL: NO CHANGE
    file = open(outputfiles.pythonIntegrationFile, 'w')
    file.write('#/\n#/ generated by ByoDyn version %s\n#/\nimport scipy\nfrom scipy.integrate import odeint\nimport math\nfrom scipy import exp\nfrom scipy import sqrt\nfrom scipy import ceil\nfrom scipy import sin\nfrom scipy import pi\n'%initiator.BYODYNVERSION)
    #/ writting sbml defined functions
    for function in model.functions:
        file.write('def %s(' %(function.id))
        file.write('%s' %function.arguments[0])
        for argument in function.arguments[1:]:
            file.write(', %s' %argument)
        file.write('):\n')    
        squareRootDefinitions = re.findall('root\(2, [\w\[\]()/\+\-\*\s\d\.\^\,]*\)', function.output)
        if len(squareRootDefinitions) != 0:
            function.output = function.output.replace('root(2, ', 'sqrt(')
        file.write('\treturn %s\n' %function.output)
    #/ 2.1 defining the topology
    file.write('def func(x, t, *args):\n')
    file.write('\txdot = [0.0')
    for i in range(len(initialVariablesValues)-1):
        file.write(', 0.0')
    file.write(']\n')
    for i in range (model.xlength):
        for j in range (model.ywidth):
            for node in variables:
                file.write('\txdot[%s] = ' %(equationNumber))
                equationNumber = equationNumber + 1               
                first = 0
                for definition in model.topology.keys():
                    fieldsDefinition = definition.split('/')
                    if fieldsDefinition[0] == node:
                        exec "%s(model, file, option, cellIndex, definition, fieldsDefinition)"%fieldsDefinition[1]
                        first = 1
                if first == 0:
                    file.write('0')
                file.write('\n')
            cellIndex = cellIndex + 1
    if metamodel.velocities == True:
        file.write('\tg.write(\'%s')
        for i in range(len(initialVariablesValues)):
            file.write('\\t%s')
        file.write('\\n\'%(t')
        for i in range(len(initialVariablesValues)):
            file.write(', xdot[%s]' %i)
        file.write('))\n')
    file.write('\treturn xdot\n')
    file.write('t = scipy.arange(0, %s, %s)\n' %(metamodel.simulationTime + metamodel.simulationTimeStep, metamodel.simulationTimeStep))
    for parameter in model.parameters.keys():
        file.write('%s = %s\n'%(parameter, model.parameters[parameter]))
        args.append(parameter)
    for compartment in model.compartments.keys():
        file.write('%s = %s\n'%(compartment, model.compartments[compartment]['size']))
        args.append(compartment)      
    for specie in model.constantNodes.keys():
        file.write('%s = %s\n'%(specie, model.constantNodes[specie]))
        args.append(specie)      
    file.write('parameters = [%s' %args[0])
    for i in range(len(args) - 1):
        file.write(', %s' %args[i + 1])
    file.write(']\n')  
    if model.xlength != 1 or model.ywidth != 1: #/ multicellular model
	file.write('x_0 = [%s' %model.initialConditions[0])
	for i in range(len(model.initialConditions) - 1):
	    file.write(', %s' %model.initialConditions[i + 1])
    else:
	file.write('x_0 = [%s' %initialVariablesValues[0])
	for i in range(len(initialVariablesValues) - 1):
	    file.write(', %s' %initialVariablesValues[i + 1])    
    file.write(']\n')
    if metamodel.velocities == True:
	file.write('g = open(\'%s\', \'w\')\n' %outputfiles.velocitiesFile)
	file.write('g.write(\'#\\n# generated by ByoDyn version %s\\n#\\n\')\n'%initiator.BYODYNVERSION)
	file.write('g.write(\'# t')
	if model.xlength != 1  or model.ywidth != 1:
	    for i in range(model.xlength):
		for j in range(model.ywidth):
		    for k in range(len(model.nodes)):
			file.write('\\t%s(%s,%s)'%(model.nodes[k],i,j))
	else:
	    for i in range(len(initialVariablesValues)):
		file.write('\\t%s' %variables[i]) 
        file.write('\\n\')\n')
        file.write('args = (parameters,g)\n') 
    else:
	file.write('args = (parameters,)\n') #/ the comma is necessary for the tuple
    file.write('x = odeint(func, x_0, t, args)\n')
    if metamodel.velocities == True:
	file.write('g.close()\n')
    file.write('f = open(\'%s\', \'w\', 1048576)\n' %outputfiles.simulationResults)
    file.write('f.write(\'#\\n# generated by ByoDyn version %s\\n#\\n\')\n'%initiator.BYODYNVERSION)
    file.write('f.write(\'# t')
    if model.xlength != 1 or model.ywidth != 1:
        for i in range(model.xlength):
            for j in range(model.ywidth):
                for k in range(len(model.nodes)):
                    file.write('\\t%s(%s,%s)'%(model.nodes[k],i,j))
    else:
	for i in range(len(initialVariablesValues)):
	    file.write('\\t%s' %variables[i])
    file.write('\\n\')\n')
    file.write('for i in range(len(t)):\n')
    file.write('\tf.write(\'%s') 
    if model.xlength != 1 or model.ywidth != 1:
	for i in range(len(model.initialConditions)):
	    file.write('\\t%s')
    else:
	for i in range(len(initialVariablesValues)):
	    file.write('\\t%s')
    file.write('\\n\'%(t[i]')
    if model.xlength != 1 or model.ywidth != 1:
	for i in range(len(model.initialConditions)):
	    file.write(', x[i][%s]'%(i))
    else:
	for i in range(len(initialVariablesValues)):
	    file.write(', x[i][%s]'%(i))
    file.write('))\n')
    file.write('f.close()')    
    if 'csv' in metamodel.optionalOutputFormat:
        file.write('\ng = open(\'%s\', \'w\', 1048576)\n' %outputfiles.simulationResultsCSV)
	file.write("g.write(\'#\\n# generated by ByoDyn version %s\\n#\\n')\n"%initiator.BYODYNVERSION)
        file.write('g.write(\'time')
        if model.xlength != 1 or model.ywidth != 1:
            for i in range(model.xlength):
                for j in range(model.ywidth):
                    for k in range(len(model.nodes)):
                        file.write(',%s(%s-%s)'%(model.nodes[k],i,j))
        else:
            for i in range(len(initialVariablesValues)):
                file.write(',%s' %variables[i])
        file.write('\\n\')\n')
        file.write('for i in range(len(t)):\n')
        file.write('\tg.write(\'%s')
        if model.xlength != 1 or model.ywidth != 1:
            for i in range(len(model.initialConditions)):
                file.write(',%s')
        else:
            for i in range(len(initialVariablesValues)):
                file.write(',%s')
        file.write('\\n\'%(t[i]')
        if model.xlength != 1 or model.ywidth != 1:
            for i in range(len(model.initialConditions)):
               file.write(', x[i][%s]'%(i))
        else:
           for i in range(len(initialVariablesValues)):
               file.write(', x[i][%s]'%(i))
        file.write('))\n')
        file.write('g.close()')
    file.close()

    return None

def createOctaveOutputs(model, metamodel, outputfiles):

    ''' 
    This function merges the Octave outputs and sets the header of the file consisting on the model nodes and the model rules.
    '''

    os.system('paste %s %s > %s' %(outputfiles.octaveIntegrationTime, outputfiles.octaveIntegrationData, outputfiles.simulationResults))
    #/ 1.- modifying the headers only to append the rules
    stringNodes = '# t'

    for n in model.nodes:
        if model.constantNodes.keys().count(n) == 0:
            stringNodes = stringNodes + '\t' + n
    for n in model.algebraicNodes:
            stringNodes = stringNodes + '\t' + n
    for n in model.nonConstantParameters:
            stringNodes = stringNodes + '\t' + n
    for n in model.nonConstantCompartments:
            stringNodes = stringNodes + '\t' + n

    stringNodes = stringNodes + '\n'
    results = open(outputfiles.simulationResults, 'r')
    lines = results.readlines()
    results.close()
    for l in range(len(lines)):
        if lines[l].split()[0] != '#':
            lines.insert(l, stringNodes)
            break
    results = open(outputfiles.simulationResults, 'w')
    results.writelines(lines)
    results.close()
    #/ 2.- creating the comma separated value file if necessary
    if 'csv' in metamodel.optionalOutputFormat:
	file = open(outputfiles.simulationResultsCSV, 'w')
	file.write('#\n# generated by ByoDyn version 3.19\n#\n')
	file.write(stringNodes)
	for l in range(len(lines)):
	    if lines[l].split()[0] != '#':
		vector = lines[l].split()
		file.write('%s'%vector[0])
		for i in range(len(vector)-1):
		    file.write(',%s'%vector[i+1])
		file.write('\n')
	file.close()    
            
    return None

def matlabIntegrator(metamodel, model, outputfiles):

    ''' 
    This function is under construction.
    '''
    
    return None

def neighboursFinder(model, cellIndex):

    ''' 
    This function determines the cell neighbour nodes of a given node. 
    The system needs to be multicellular.
    '''

    #/ 1.- determining localization
    loc = []
    indexX = cellIndex / model.xlength
    indexY = cellIndex - ((cellIndex / model.xlength) * model.xlength)
    loc.append(indexX)
    loc.append(indexY)
    #/ 2.- determining neighboors
    neighbours = [] #/ the neighbour cells
    imaginaryNeighbours = [] #/ all the possible neighbour cells
    N = [loc[0] - 1, loc[1]]
    NE = [loc[0] - 1, loc[1] + 1]
    E = [loc[0], loc[1] + 1]
    SE = [loc[0] + 1, loc[1] + 1]
    S = [loc[0] + 1, loc[1]]
    SW = [loc[0] + 1, loc[1] - 1]
    W = [loc[0], loc[1] - 1]
    NW = [loc[0] - 1, loc[1] - 1]
    imaginaryNeighbours.append(N), imaginaryNeighbours.append(NE), imaginaryNeighbours.append(E), imaginaryNeighbours.append(SE), imaginaryNeighbours.append(S), imaginaryNeighbours.append(SW), imaginaryNeighbours.append(W), imaginaryNeighbours.append(NW)
    #/ 3.- determining the neighbours out of range
    for i in range(8):
        if imaginaryNeighbours[i][0] < 0 or imaginaryNeighbours[i][0] >= model.ywidth:
            imaginaryNeighbours[i][0] = 'error'
        if imaginaryNeighbours[i][1] < 0 or imaginaryNeighbours[i][1] >= model.xlength:
            imaginaryNeighbours[i][1] = 'error'   
    #/ 4.- creating the new variable without the non-existing neigbors
    for i in range(8):
        if imaginaryNeighbours[i][0] != 'error' and imaginaryNeighbours[i][1] != 'error':
            neighbours.append(imaginaryNeighbours[i])

    return neighbours
    
def octaveIntegration(metamodel, model, outputfiles):

    ''' 
    This function directs the main steps to simulate the system using Octave as the integrator. 
    '''

    createInputOctave(metamodel, model, outputfiles)
    callingOctave(outputfiles)
    createOctaveOutputs(model, metamodel, outputfiles)
    
    return None

def pythonIntegration(metamodel, model, outputfiles):

    '''
    This function directs the main steps to simulate the system using SciPy as the integrator.
    '''

    createInputPython(metamodel, model, outputfiles)
    callingPython(outputfiles)

    return None
            
def writeFormulaOctave(model, node, octave, option, cellIndex):

    '''
    This function calls to the different functions of the module affectors from the lib directory.
    Each affector writes the specific formula.
    There is a general function for the SBML files.
    '''

    first = 0
    for definition in model.topology.keys():
        fieldsDefinition = definition.split("/")
        if fieldsDefinition[0] == node:
            exec "%s(model, octave, option, cellIndex, definition, fieldsDefinition)"%fieldsDefinition[1]
            first = 1
    if first == 0:
        octave.write('+ 0')
    octave.write(';\n')

    return None

def writeInitialConditionsOctave(model, metamodel, octave, function):

    '''
    This function writes the initial conditions for the octave option.
    It takes into account the model rules for the non constant parameters and the non constant compartments.
    It also writes down the integration time and time step.
    '''
    
    zeros = []
    initialValues = []
    for n in model.nodes:
        if model.constantNodes.keys().count(n) == 0:
            zeros.append(0.0)
            initialValues.append(model.initialConditions[model.nodes.index(n)])
    for n in model.algebraicNodes:
        zeros.append(0.0)
        initialValues.append(model.algebraicNodes[n])
    for n in model.nonConstantParameters:
        zeros.append(0.0)
        initialValues.append(model.nonConstantParameters[n])
    for n in model.nonConstantCompartments:
        zeros.append(0.0)
        initialValues.append(model.nonConstantCompartments[n]['size'])
    if function == 'daspk':    
	octave.write('xdot0 = %s;\n' %(zeros))
    if model.xlength != 1 or model.ywidth != 1:
	initialValues = model.initialConditions
    octave.write('# these are the initial conditions for each node used on the run\n')
    octave.write('x0 = %s;\n' %(initialValues))
    simulationSteps = metamodel.simulationTime / metamodel.simulationTimeStep #/ calculation the simulation steps
    octave.write('t = linspace (0, %s, %s)\';\n' %(metamodel.simulationTime, simulationSteps))
    
    return None
    
def writeParametersOctave(model, octave):

    '''
    This function sets the parameters values for the octave input file.
    It also takes into account the compartment values as plausible parameters of the model as they are commonly used as a parameter of the system of equations.
    '''
    
    octave.write('#\n# these are the parameters used on the run\n#\n')
    for parameter in model.parameters.keys():
        octave.write('%s = %s;\n'%(parameter, model.parameters[parameter]))
    for compartment in model.compartments.keys():
        octave.write('%s = %s;\n'%(compartment, model.compartments[compartment]['size']))
    for specie in model.constantNodes.keys():
        octave.write('%s = %s;\n'%(specie, model.constantNodes[specie]))
    return None
