#
#  Project: ByoDyn
#
#  Copyright (C) 2008 Alex Gomez-Garrido and Adrian L. Garcia-Lomana and Jordi Villa-Freixa
#
#  Author: Alex Gomez-Garrido and David Sportouch
#
#  Created: 2007-07-18 by Alex Gomez-Garrido
#
#  This application is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
#  This application is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Library General Public License for more details.
#
#  You should have received a copy of the GNU General Public
#  License along with this library; if not, write to the Free
#  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
# 

# $Id: matrixWorker.py,v 4.8 2008/12/03 16:37:38 alglomana Exp $

import math, scipy, scipy.linalg, os, sys
import errorMessages, initiator

class ClassMatrix:

    def __init__(self):

	'''
	Constructor of the class ClassMatrix.
	'''

        self.m = []
        self.eigenValues = []
        self.eigenVectors = []
        self.rowNames = []
        self.colNames = []

    def blackAndWhiteColorCalculator(self, value, max):
	
	'''
	This function calculates the colour intensity in the black-white scale.
	'''

        G = 1 - value/max
        B = 1 - value/max
        R = 1 - value/max
        
        return R, G, B

    def blueRedColorCalculator(self, value, max):

	'''
	This function calculates the colour intensity in a blue-red scale.
	'''
     
        if value > 0:
            R = value / max
            G = B = 1.0 - R
            R = 1.0
        elif value < 0:
            value = -value
            B = value / max
            R = G = 1.0 - B
            B = 1.0
        else:
            raise errorMessages.ClassMatrixWorkerException, 'problems during colour calculation.'
	            
        return R, G, B

    def fileWriter(self, message, outputFile):
	
	'''
	This function writes a text file with a matrix.
	'''
     
	f = open(outputFile, 'w')
        f.write('#\n# generated by ByoDyn version %s\n#\n'%initiator.BYODYNVERSION)
	f.write('#\n# %s\n#\n'%message)
	if self.colNames != []:
	    f.write('\t')
	    for colName in self.colNames:
		f.write('%s\t' %colName)
	    f.write('\n')
	for i in range(len(self.m)):
            if self.rowNames != []:
                f.write('%s\t' %self.rowNames[i])
            for element in self.m[i]:
                f.write('%s\t' %element)
            f.write('\n')
        f.close()
        
	return None

    def getCovarianceMatrix(self):
        return scipy.dot(scipy.array(self.m), scipy.array(self.m).transpose()) / len(self.m)

    def getEmpiricalMean(self):
        return scipy.array((map(sum, scipy.array(self.m))))/len(self.m[0])

    def getMaxEigenValue(self):

	'''
	This function returns the largest eigenvalue of a matrix.
	'''

        if self.eigenValues == []:
            self.setEigenValues()          
        floatValues = []
        for value in self.eigenValues:
            floatValues.append(abs(value))

        return max(floatValues)
  
    def getMinEigenValue(self):

	'''
	This function returns the lowest eigenvalue of a matrix.
	'''

        if self.eigenValues == []:
            self.setEigenValues()
        floatValues = []
        for value in self.eigenValues:
            floatValues.append(abs(value))

        return min(floatValues)

    def getTrace(self):

	'''
	This function calculates the trace of a matrix: summing up the diagonal.
	'''

        value = 0.
        for i in range(len(self.m)):
            value = value + self.m[i][i]

        return value

    def isSingular(self):

	'''
	This function returns true if the matrix is singular.
	'''
    
        if scipy.linalg.det(self.m) == 0:
            return True
        else:
            return False

    def plotWriter(self, metamodel, outputFile, color):

	'''
	This function creates a postscript file with a black and white or color matrix.
	'''

        size = [len(self.m), len(self.m[0])]
        f = open(outputFile, 'w')
        #/ 1.- writing postscript functions
        libdir = os.environ.get('BYODYN_PATH') + '/lib'
        #/ 1.1.- first obtain some information at the library necessary for the postscript file
        headerFile = open('%s/postscript/header.ps' %libdir, 'r')
        header =  headerFile.readlines()
        headerFile.close()
        for line in header:
            f.write('%s' %line)
        boxFile = open('%s/postscript/box.ps' %libdir, 'r')
        box =  boxFile.readlines()
        boxFile.close()
        for line in box:
            f.write('%s' %line)
        frameFile = open('%s/postscript/boxFrame.ps' %libdir, 'r')
        frame =  frameFile.readlines()
        frameFile.close()
        for line in frame:
            f.write('%s' %line)
	#/ 1.2.- slanted font
	slantedFont = []
	slantedfontFile = open('%s/postscript/slantedFont.ps' %libdir, 'r')
        rowSlantedFont = slantedfontFile.readlines() 
        slantedfontFile.close()  
	for line in rowSlantedFont:
	    if line[0] != '%':
		slantedFont.append(line)
	#/ 1.3.- slanted font definition
	for line in slantedFont:
	    f.write('%s\n'%line)
        #/ 2.- calculating the boxes
        #/ 2.1.- dimensions
        boxSize = 20 #/ you have to reset the size if the graph goes larger than the page
        xIni = 25.0 
        yIni = 740.0 - boxSize 
        xFin = 25.0 + boxSize 
        yFin = 740.0 
        #/ 2.3.- calculation of the max value
        allValues = []        
        for i in range(len(self.m)):
            for j in range(len(self.m[i])):
                allValues.append(abs(self.m[i][j]))
        maxValue = max(allValues)
        #/ 2.4.- printing the matrix
        for i in range(size[0]):
            for j in range(size[1]):
                if color == 'blackAndWhite':
                    R, G, B = self.blackAndWhiteColorCalculator(self.m[i][j], maxValue)
                elif color == 'blueRed':
                    R, G, B = self.blueRedColorCalculator(self.m[i][j], maxValue)
                else:
                    raise errorMessages.ClassMatrixWorkerException, 'not defined the color of the graph.'
                f.write('%s %s %s %s %s %s %s boxRGB\n' %(xIni, yIni, xFin, yFin, R, G, B))
                f.write('%s %s %s %s 0.5 boxFrame\n'%(xIni, yIni, xFin, yFin))
                xIni += boxSize
                xFin += boxSize
                if i == 0 and self.colNames != []:
                    f.write('newpath %s %s moveto (%s) show\n' %((xIni-boxSize/2), (yIni+(boxSize*3/2)), self.colNames[j]))
            #/ writing the paramter names at the right of the graph
            if self.rowNames != []:
                f.write('newpath %s %s moveto (%s) show\n' %((xFin-boxSize/2), (yFin-boxSize/2), self.rowNames[i]))
            yIni = yIni - boxSize
            yFin = yFin - boxSize
            xIni = 25.0
            xFin = 25.0 + boxSize 
        f.write('showpage\n')
        f.close() 
	#/ 3.- converting to png if it is the case
	if metamodel.figureFormat == 'png':
	    pngFile = outputFile.replace('ps', 'png')
	    cmd = 'convert %s %s'%(outputFile, pngFile)
	    os.system(cmd)

        return None

    def setEigenValues(self):

	'''
	This function calculates the eigenvalues of a matrix using SciPy.
	'''
	
        self.eigenValues, self.eigenVectors = scipy.linalg.eig(self.m)

        return None

    def setColNames(self, names):      

	'''
	This function sets the names of the columns of the matrix.
	'''

        self.colNames = names           

        return None
       
    def setRowNames(self, names):      

	'''
	This function sets the names of the rows of the matrix.
	'''

        self.rowNames = names     

        return None
