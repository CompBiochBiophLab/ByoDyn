#
#  Project: ByoDyn
#
#  Copyright (C) 2008 Adrian L. Garcia-Lomana & Jordi Villa-Freixa
#
#  Author: Adrian L. Garcia-Lomana and Alex Gomez-Garrido
#
#  Created: 2004-08-30 by Adrian L. Garcia-Lomana
#
#  This application is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
#  This application is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Library General Public License for more details.
#
#  You should have received a copy of the GNU General Public
#  License along with this library; if not, write to the Free
#  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
#

# $Id: checker.py,v 4.40 2008/12/17 01:04:42 alglomana Exp $

## \file 
# This module is responsible of running the tests of the program.

import os, sys, time, glob
import central, testers, initiator, errorMessages

class ClassChecker:

    '''
    Class for the checking of the program.
    '''
    
    def __init__(self):

	'''
	The constructor.
	'''

		
	self.OctaveFound = False
	self.OpenModelicaFound = False
	self.ScipyFound = False
	self.XPPFound = False
        self.listOfTests = []
        self.log = {}
	outputDir = os.environ.get('BYODYN_OUTPUT_DIR')
        self.logFile = outputDir + '/testResults.log'         

        return None
    
    def __printLog(self, summaryMessage):

	'''
	This method prints the results of the tests.
	'''

        print 'Results obtained saved on %s' %self.logFile
	print summaryMessage
	
	return None
    
    def __writeLogFile(self):

	'''
	This method saves the results from the tests to a file.
	'''
	
        print 'Saving results in log file ...'
	summaryMessage = None
	allPassed = True
	failedTests = []
	f = open(self.logFile, 'w')
	f.write('#\n# generated by ByoDyn version %s\n#\n'%initiator.BYODYNVERSION)
	f.write('Run tests ...\n')
	for test in self.listOfTests:
	    f.write('\t%s\t%s\n'%(test.id, self.log[test.id]))
	    if self.log[test.id] != 'OK':
		allPassed = False
		failedTests.append(test.id)
	if allPassed == True:
	    f.write('All tests passed.')
	    summaryMessage = 'All tests passed.'
	else:
	    f.write('Failed tests:\n')
	    for test in failedTests:
		f.write('\t%s'%test)
	    summaryMessage = 'Some tests failed, check the log file for further information.\nPlease contact the ByoDyn team at "https://lists.sourceforge.net/lists/listinfo/byodyn-users".'
	f.close()
	
	return summaryMessage
    
    def chooser(self):
	
	'''
	This method selects the appropriate tests to run depending on the machine software'
	'''
	
	#/ number of tests is 57

        #/ 1.- testing exporting
	exportingTest = testers.ClassExportingTest()
	self.listOfTests.append(exportingTest)
        #/ 2.- testing simulation
        #/ 2.1.- Scipy
	if self.ScipyFound == True:
	    #/ 2.1.1.- regular simulation
	    simulatorScipy = testers.ClassSciPyTest()
	    self.listOfTests.append(simulatorScipy)
	    #/ 2.1.2.- integration methods for simulation: adams, non-stiff, bdf and stiff
	    #/ 2.1.2.1.- adams
	    adamsScipy = testers.ClassSimulationMethodsTest()
	    adamsScipy.id = 'adamsScipy'
	    adamsScipy.runner = adamsScipy.setRunnerName('adamsScipy.rn')
	    adamsScipy.expectedResult = adamsScipy.setResultName('adamsScipy.out')
	    adamsScipy.obtainedResult = adamsScipy.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(adamsScipy)
	    #/ 2.1.2.2.- non-stiff
	    nonStiffScipy = testers.ClassSimulationMethodsTest()
	    nonStiffScipy.id = 'nonStiffScipy'
	    nonStiffScipy.runner = nonStiffScipy.setRunnerName('nonStiffScipy.rn')
	    nonStiffScipy.expectedResult = nonStiffScipy.setResultName('nonStiffScipy.out')
	    nonStiffScipy.obtainedResult = nonStiffScipy.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(nonStiffScipy)
	    #/ 2.1.2.3.- bdf
	    bdfScipy = testers.ClassSimulationMethodsTest()
	    bdfScipy.id = 'bdfScipy'
	    bdfScipy.runner = bdfScipy.setRunnerName('bdfScipy.rn')
	    bdfScipy.expectedResult = bdfScipy.setResultName('bdfScipy.out')
	    bdfScipy.obtainedResult = bdfScipy.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(bdfScipy)
	    #/ 2.1.2.4.- stiff
	    stiffScipy = testers.ClassSimulationMethodsTest()
	    stiffScipy.id = 'stiffScipy'
	    stiffScipy.runner = stiffScipy.setRunnerName('stiffScipy.rn')
	    stiffScipy.expectedResult = stiffScipy.setResultName('stiffScipy.out')
	    stiffScipy.obtainedResult = stiffScipy.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(stiffScipy)
	    #/ 2.1.3.- SBML features: rate rules and function definitions
	    #/ 2.1.3.1.- rate rules
	    #/ no sbml available with only rate rules
	    #/ 2.1.3.2.- function definitions
	    functionDefinitionsScipy = testers.ClassSimulationMethodsTest()
	    functionDefinitionsScipy.id = 'functionDefinitionsScipy'
	    functionDefinitionsScipy.runner = functionDefinitionsScipy.setRunnerName('functionDefinitionsScipy.rn')
	    functionDefinitionsScipy.expectedResult = functionDefinitionsScipy.setResultName('functionDefinitionsScipy.out')
	    functionDefinitionsScipy.obtainedResult = functionDefinitionsScipy.setOutputName('Model_1.0.out')
	    self.listOfTests.append(functionDefinitionsScipy)
	    #/ 2.1.4.- general optional fields of simulation: parameter, time&timestep, checkConsistencySBML and figureFormat
	    #/ 2.1.4.1.- parameter
	    #/ already done in exporting
	    #/ 2.1.4.2.- time&time 
	    #/ already done on previous tests
	    #/ 2.1.4.3.- checkConsistencySBML
	    checkConsistency = testers.ClassSimulationMethodsTest()
	    checkConsistency.id = 'checkConsistency'
	    checkConsistency.runner = checkConsistency.setRunnerName('checkConsistency.rn')
	    checkConsistency.expectedResult = checkConsistency.setResultName('checkConsistency.out')
	    checkConsistency.obtainedResult = checkConsistency.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    #!!!self.listOfTests.append(checkConsistency) it fails for all (not exhaustively) checked biomodels using libsbml 3.1.1
	    #/ 2.1.4.4.- figureFormat
	    figureFormat = testers.ClassFigureFormatTest()
	    figureFormat.id = 'figureFormat'
	    figureFormat.runner = figureFormat.setRunnerName('figureFormat.rn')
	    figureFormat.obtainedResult = figureFormat.setOutputName('Kinetic_modelling_of_Amadori_degradation.png')
	    self.listOfTests.append(figureFormat)
	    #/ 2.1.5.- optional arguments for simulation. Tested on python but available from any simulator.
	    #/ 2.1.5.1.- plotKeys
	    plotKeys = testers.ClassPlotKeysTest()
	    plotKeys.id = 'plotKeys'
	    plotKeys.runner = plotKeys.setRunnerName('plotKeys.rn')
	    plotKeys.obtainedResult = plotKeys.setOutputName('/scratch/Kinetic_modelling_of_Amadori_degradation.gnu')
	    self.listOfTests.append(plotKeys)
	    #/ 2.1.5.2.- optionalOutputFormat
	    optionalOutputFormat = testers.ClassOptionalOutputFormatTest()
	    optionalOutputFormat.id = 'optionalOutputFormat'
	    optionalOutputFormat.runner = optionalOutputFormat.setRunnerName('optionalOutputFormat.rn')
	    optionalOutputFormat.obtainedResult = optionalOutputFormat.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.csv')
	    self.listOfTests.append(optionalOutputFormat)
	    #/ 2.1.5.3.- withoutGraphics
	    withoutGraphics = testers.ClassWithoutGraphicsTest()
	    withoutGraphics.id = 'withoutGraphics'
	    withoutGraphics.runner = withoutGraphics.setRunnerName('withoutGraphics.rn')
	    withoutGraphics.obtainedResult = withoutGraphics.setOutputName('Kinetic_modelling_of_Amadori_degradation.ps')
	    self.listOfTests.append(withoutGraphics)
	    #/ 2.1.5.4.- separatedGraphs
	    separatedGraphs = testers.ClassSeparatedGraphsTest()
	    separatedGraphs.id = 'separatedGraphs'
	    separatedGraphs.runner = separatedGraphs.setRunnerName('separatedGraphs.rn')
	    separatedGraphs.obtainedResults = separatedGraphs.setOutputName('')
	    self.listOfTests.append(separatedGraphs)
        #/ 2.2.- Octave
	if self.OctaveFound == True:
	    #/ 2.2.1.- regular simulation
	    simulatorOctave = testers.ClassSimulationMethodsTest()
	    simulatorOctave.id = 'simulatorOctave'
	    simulatorOctave.runner = simulatorOctave.setRunnerName('simulatorOctave.rn')
	    simulatorOctave.expectedResult = simulatorOctave.setResultName('simulatorOctave.out')
	    simulatorOctave.obtainedResult = simulatorOctave.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(simulatorOctave)
	    #/ 2.2.2.- integration methods, adams, non-stiff, bdf and stiff
	    #/ 2.2.2.1.- adams
	    adamsOctave = testers.ClassSimulationMethodsTest()
	    adamsOctave.id = 'adamsOctave'
	    adamsOctave.runner = adamsOctave.setRunnerName('adamsOctave.rn')
	    adamsOctave.expectedResult = adamsOctave.setResultName('adamsOctave.out')
	    adamsOctave.obtainedResult = adamsOctave.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(adamsOctave)
	    #/ 2.2.2.2.- non-stiff
	    nonStiffOctave = testers.ClassSimulationMethodsTest()
	    nonStiffOctave.id = 'nonStiffOctave'
	    nonStiffOctave.runner = nonStiffOctave.setRunnerName('nonStiffOctave.rn')
	    nonStiffOctave.expectedResult = nonStiffOctave.setResultName('nonStiffOctave.out')
	    nonStiffOctave.obtainedResult = nonStiffOctave.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(nonStiffOctave)
	    #/ 2.2.2.3.- bdf
	    bdfOctave = testers.ClassSimulationMethodsTest()
	    bdfOctave.id = 'bdfOctave'
	    bdfOctave.runner = bdfOctave.setRunnerName('bdfOctave.rn')
	    bdfOctave.expectedResult = bdfOctave.setResultName('bdfOctave.out')
	    bdfOctave.obtainedResult = bdfOctave.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(bdfOctave)
	    #/ 2.2.2.4.- stiff
	    stiffOctave = testers.ClassSimulationMethodsTest()
	    stiffOctave.id = 'stiffOctave'
	    stiffOctave.runner = stiffOctave.setRunnerName('stiffOctave.rn')
	    stiffOctave.expectedResult = stiffOctave.setResultName('stiffOctave.out')
	    stiffOctave.obtainedResult = stiffOctave.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(stiffOctave)
	    #/ 2.2.3.- SBML features
	    #/ 2.2.3.1.- rate and assignment rules. The only model containing algebraic rules, BIOMODEL 56, it also contains events and therefore it cannot be tested under octave.
	    rulesOctave = testers.ClassSimulationMethodsTest()
	    rulesOctave.id = 'rulesOctave'
	    rulesOctave.runner = rulesOctave.setRunnerName('rulesOctave.rn')
	    rulesOctave.expectedResult = rulesOctave.setResultName('rulesOctave.out')
	    rulesOctave.obtainedResult = rulesOctave.setOutputName('hhsa_1952.0.out')
	    self.listOfTests.append(rulesOctave)
	    #/ 2.2.3.2.- function definitions
	    functionDefinitionsOctave = testers.ClassSimulationMethodsTest()
	    functionDefinitionsOctave.id = 'functionDefinitionsOctave'
	    functionDefinitionsOctave.runner = functionDefinitionsOctave.setRunnerName('functionDefinitionsOctave.rn')
	    functionDefinitionsOctave.expectedResult = functionDefinitionsOctave.setResultName('functionDefinitionsOctave.out')
	    functionDefinitionsOctave.obtainedResult = functionDefinitionsOctave.setOutputName('Model_1.0.out')
	    self.listOfTests.append(functionDefinitionsOctave)
        #/ 2.3.- XPP
	if self.XPPFound == True:
	    #/ 2.3.1.- regular simulation
	    simulatorXPP = testers.ClassSimulationMethodsTest()
	    simulatorXPP.id = 'simulatorXPP'
	    simulatorXPP.runner = simulatorXPP.setRunnerName('simulatorXPP.rn')
	    simulatorXPP.expectedResult = simulatorXPP.setResultName('simulatorXPP.out')
	    simulatorXPP.obtainedResult = simulatorXPP.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(simulatorXPP)
	    #/ 2.3.2.- SBML features
	    #/ 2.3.2.1.- delays
	    delaysXPP = testers.ClassSimulationMethodsTest()
	    delaysXPP.id = 'delaysXPP'
	    delaysXPP.runner = delaysXPP.setRunnerName('delaysXPP.rn')
	    delaysXPP.expectedResult = delaysXPP.setResultName('delaysXPP.out')
	    delaysXPP.obtainedResult = delaysXPP.setOutputName('Scheper1999.0.out')
	    self.listOfTests.append(delaysXPP)
	    #/ 2.3.2.3.- function definitions
	    functionDefinitionsXPP = testers.ClassSimulationMethodsTest()
	    functionDefinitionsXPP.id = 'functionDefinitionsXPP'
	    functionDefinitionsXPP.runner = functionDefinitionsXPP.setRunnerName('functionDefinitionsXPP.rn')
	    functionDefinitionsXPP.expectedResult = functionDefinitionsXPP.setResultName('functionDefinitionsXPP.out')
	    functionDefinitionsXPP.obtainedResult = functionDefinitionsXPP.setOutputName('Model_1.0.out')
	    self.listOfTests.append(functionDefinitionsXPP)
        #/ 2.4.- OpenModelica
	if self.OpenModelicaFound == True:
	    #/ 2.4.1.- regular simulation
	    simulatorModelica = testers.ClassSimulationMethodsTest()
	    simulatorModelica.id = 'simulatorModelica'
	    simulatorModelica.runner = simulatorModelica.setRunnerName('simulatorModelica.rn')
	    simulatorModelica.expectedResult = simulatorModelica.setResultName('simulatorModelica.out')
	    simulatorModelica.obtainedResult = simulatorModelica.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	    self.listOfTests.append(simulatorModelica)
	    #/ 2.4.1.- rate and assignment rules
	    rulesModelica = testers.ClassSimulationMethodsTest()
	    rulesModelica.id = 'rulesModelica'
	    rulesModelica.runner = rulesModelica.setRunnerName('rulesModelica.rn')
	    rulesModelica.expectedResult = rulesModelica.setResultName('rulesModelica.out')
	    rulesModelica.obtainedResult = rulesModelica.setOutputName('hhsa_1952.0.out')
	    self.listOfTests.append(rulesModelica)
	    #/ 2.4.2.- algebraic rules and events (BIOMODEL 56). It contains assignment rules and function definitions
	    algebraicRulesAndEventsModelica = testers.ClassSimulationMethodsTest()
	    algebraicRulesAndEventsModelica.id = 'algebraicRulesAndEventsModelica'
	    algebraicRulesAndEventsModelica.runner = algebraicRulesAndEventsModelica.setRunnerName('algebraicRulesAndEventsModelica.rn')
	    algebraicRulesAndEventsModelica.expectedResult = algebraicRulesAndEventsModelica.setResultName('algebraicRulesAndEventsModelica.out')
	    algebraicRulesAndEventsModelica.obtainedResult = algebraicRulesAndEventsModelica.setOutputName('withoutId.0.out')
	    self.listOfTests.append(algebraicRulesAndEventsModelica)
	#/ 2.5.- test for automatic simulator
	simulatorAutomatic = testers.ClassSimulationMethodsTest()
	simulatorAutomatic.id = 'simulatorAutomatic'
	simulatorAutomatic.runner = simulatorAutomatic.setRunnerName('simulatorAutomatic.rn')
	simulatorAutomatic.expectedResult = simulatorAutomatic.setResultName('scipyODE.out')
	simulatorAutomatic.obtainedResult = simulatorAutomatic.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	self.listOfTests.append(simulatorAutomatic)
	#/ 2.6.- euler and runge-kutta simulator
	#/ 2.6.1.- euler
	simulatorEuler = testers.ClassSimulationMethodsTest()
	simulatorEuler.id = 'simulatorEuler'
	simulatorEuler.runner = simulatorEuler.setRunnerName('simulatorEuler.rn')
	simulatorEuler.expectedResult = simulatorEuler.setResultName('simulatorEuler.out')
	simulatorEuler.obtainedResult = simulatorEuler.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	self.listOfTests.append(simulatorEuler) 
	#/ 2.6.2.- runge-kutta 
	simulatorRungeKutta = testers.ClassSimulationMethodsTest()
	simulatorRungeKutta.id = 'simulatorRungeKutta'
	simulatorRungeKutta.runner = simulatorRungeKutta.setRunnerName('simulatorRungeKutta.rn')
	simulatorRungeKutta.expectedResult = simulatorRungeKutta.setResultName('simulatorRungeKutta.out')
	simulatorRungeKutta.obtainedResult = simulatorRungeKutta.setOutputName('Kinetic_modelling_of_Amadori_degradation.0.out')
	self.listOfTests.append(simulatorRungeKutta) 
	#/ 3.- testing stochastic simulations
	#/ 3.1.- gillespie. Checking the variance at the steady state
	gillespieGeneral = testers.ClassStochasticGeneralTest()
	gillespieGeneral.id = 'gillespieGeneral'
	gillespieGeneral.runner = gillespieGeneral.setRunnerName('gillespieGeneral.rn')
	gillespieGeneral.obtainedResult = gillespieGeneral.setOutputName('')
	self.listOfTests.append(gillespieGeneral)
	#/ 3.1.1.- testing for exhaustive graphs single figure
	gillespieExhaustiveSingleFigure = testers.ClassStochasticSingleFigureTest()
	gillespieExhaustiveSingleFigure.id = 'gillespieExhaustiveSingleFigure'
	gillespieExhaustiveSingleFigure.runner = gillespieExhaustiveSingleFigure.setRunnerName('gillespieExhaustiveSingleFigure.rn')
	gillespieExhaustiveSingleFigure.obtainedResult = gillespieExhaustiveSingleFigure.setOutputName('')
	self.listOfTests.append(gillespieExhaustiveSingleFigure)	
	#/ 3.1.2.- testing for exhaustive graphs in different figures
	gillespieExhaustiveSeparatedGraphs = testers.ClassStochasticSeparatedGraphsTest()
	gillespieExhaustiveSeparatedGraphs.id = 'gillespieExhaustiveSeparatedGraphs'
	gillespieExhaustiveSeparatedGraphs.runner = gillespieExhaustiveSeparatedGraphs.setRunnerName('gillespieExhaustiveSeparatedGraphs.rn')
	gillespieExhaustiveSeparatedGraphs.obtainedResult = gillespieExhaustiveSeparatedGraphs.setOutputName('')
	self.listOfTests.append(gillespieExhaustiveSeparatedGraphs)
	#/ 3.1.3.- testing for statistic graphs single figure
	# tested in the general test of gillespie
	#/ 3.1.4.- testing for statistic graphs in different figures
	gillespieStatisticSeparatedGraphs = testers.ClassStochasticSeparatedGraphsTest()
	gillespieStatisticSeparatedGraphs.id = 'gillespieStatisticSeparatedGraphs'
	gillespieStatisticSeparatedGraphs.runner = gillespieStatisticSeparatedGraphs.setRunnerName('gillespieStatisticSeparatedGraphs.rn')
	gillespieStatisticSeparatedGraphs.obtainedResult = gillespieStatisticSeparatedGraphs.setOutputName('')
	self.listOfTests.append(gillespieStatisticSeparatedGraphs)
	#/ 3.1.5.- testing for histograms in single figure
	gillespieHistogramsSingleFigure = testers.ClassStochasticLastStateTest()
	gillespieHistogramsSingleFigure.id = 'gillespieHistogramsSingleFigure'
	gillespieHistogramsSingleFigure.runner = gillespieHistogramsSingleFigure.setRunnerName('gillespieHistogramsSingleFigure.rn')
	gillespieHistogramsSingleFigure.obtainedResult = gillespieHistogramsSingleFigure.setOutputName('')
	self.listOfTests.append(gillespieHistogramsSingleFigure)
	#/ 3.1.6.- testing for histograms in separate figures
	gillespieHistogramsSeparatedGraphs = testers.ClassStochasticLastStateTest()
	gillespieHistogramsSeparatedGraphs.id = 'gillespieHistogramsSeparatedGraphs'
	gillespieHistogramsSeparatedGraphs.runner = gillespieHistogramsSeparatedGraphs.setRunnerName('gillespieHistogramsSeparatedGraphs.rn')
	gillespieHistogramsSeparatedGraphs.obtainedResult = gillespieHistogramsSeparatedGraphs.setOutputName('')
	self.listOfTests.append(gillespieHistogramsSeparatedGraphs)
	#/ 3.2.- tau-leap. Checking the variance at the steady state
	tauLeapGeneral = testers.ClassStochasticGeneralTest()
	tauLeapGeneral.id = 'tauLeapGeneral'
	tauLeapGeneral.runner = gillespieGeneral.setRunnerName('tauLeapGeneral.rn')
	tauLeapGeneral.obtainedResult = gillespieGeneral.setOutputName('')
	self.listOfTests.append(tauLeapGeneral)
	#/ 3.2.1.- testing for exhaustive graphs single figure
	tauLeapExhaustiveSingleFigure = testers.ClassStochasticSingleFigureTest()
	tauLeapExhaustiveSingleFigure.id = 'tauLeapExhaustiveSingleFigure'
	tauLeapExhaustiveSingleFigure.runner = tauLeapExhaustiveSingleFigure.setRunnerName('tauLeapExhaustiveSingleFigure.rn')
	tauLeapExhaustiveSingleFigure.obtainedResult = tauLeapExhaustiveSingleFigure.setOutputName('')
	self.listOfTests.append(tauLeapExhaustiveSingleFigure)
	#/ 3.2.2.- testing for exhaustive graphs in different figures
	tauLeapExhaustiveSeparatedGraphs = testers.ClassStochasticSeparatedGraphsTest()
	tauLeapExhaustiveSeparatedGraphs.id = 'tauLeapExhaustiveSeparatedGraphs'
	tauLeapExhaustiveSeparatedGraphs.runner = tauLeapExhaustiveSeparatedGraphs.setRunnerName('tauLeapExhaustiveSeparatedGraphs.rn')
	tauLeapExhaustiveSeparatedGraphs.obtainedResult = tauLeapExhaustiveSeparatedGraphs.setOutputName('')
	self.listOfTests.append(tauLeapExhaustiveSeparatedGraphs)
	#/ 3.2.3.- testing for statistic graphs single figure
	# tested in the general test of tau-leap
	#/ 3.2.4.- testing for statistic graphs in different figures
	tauLeapStatisticSeparatedGraphs = testers.ClassStochasticSeparatedGraphsTest()
	tauLeapStatisticSeparatedGraphs.id = 'tauLeapStatisticSeparatedGraphs'
	tauLeapStatisticSeparatedGraphs.runner = tauLeapStatisticSeparatedGraphs.setRunnerName('tauLeapStatisticSeparatedGraphs.rn')
	tauLeapStatisticSeparatedGraphs.obtainedResult = tauLeapStatisticSeparatedGraphs.setOutputName('')
	self.listOfTests.append(tauLeapStatisticSeparatedGraphs)
	#/ 3.2.5.- testing for histograms in single figure
	tauLeapHistogramsSingleFigure = testers.ClassStochasticLastStateTest()
	tauLeapHistogramsSingleFigure.id = 'tauLeapHistogramsSingleFigure'
	tauLeapHistogramsSingleFigure.runner = tauLeapHistogramsSingleFigure.setRunnerName('tauLeapHistogramsSingleFigure.rn')
	tauLeapHistogramsSingleFigure.obtainedResult = tauLeapHistogramsSingleFigure.setOutputName('')
	self.listOfTests.append(tauLeapHistogramsSingleFigure)
	#/ 3.2.6.- testing for histograms in separate figures
	tauLeapHistogramsSeparatedGraphs = testers.ClassStochasticLastStateTest()
	tauLeapHistogramsSeparatedGraphs.id = 'tauLeapHistogramsSeparatedGraphs'
	tauLeapHistogramsSeparatedGraphs.runner = tauLeapHistogramsSeparatedGraphs.setRunnerName('tauLeapHistogramsSeparatedGraphs.rn')
	tauLeapHistogramsSeparatedGraphs.obtainedResult = tauLeapHistogramsSeparatedGraphs.setOutputName('')
	self.listOfTests.append(tauLeapHistogramsSeparatedGraphs)
        #/ 4.- testing optimisation
	#/ 4.1.- random search
	randomSearchOptimisation = testers.ClassRandomSearchOptimisationTest()
	randomSearchOptimisation.id = 'randomSearchOptimisation'
	randomSearchOptimisation.runner = randomSearchOptimisation.setRunnerName('randomSearchOptimisation.rn')
	randomSearchOptimisation.obtainedResult = randomSearchOptimisation.setOutputName('Kinetic_modelling_of_Amadori_degradation/')
	self.listOfTests.append(randomSearchOptimisation)
	#/ 4.2.- local search
	localSearchOptimisation = testers.ClassLocalSearchOptimisationTest()
	localSearchOptimisation.id = 'localSearchOptimisation'
	localSearchOptimisation.runner = localSearchOptimisation.setRunnerName('localSearchOptimisation.rn')
	localSearchOptimisation.obtainedResult = localSearchOptimisation.setOutputName('Kinetic_modelling_of_Amadori_degradation/parametersFromLocalSearch/k10v10')
	self.listOfTests.append(localSearchOptimisation) 
	#/ 4.3.- genetic algorithm
	geneticAlgorithm = testers.ClassGeneticAlgorithmTest()
	geneticAlgorithm.id = 'geneticAlgorithm'
	geneticAlgorithm.runner = geneticAlgorithm.setRunnerName('geneticAlgorithm.rn')
	geneticAlgorithm.obtainedResult = geneticAlgorithm.setOutputName('')
	self.listOfTests.append(geneticAlgorithm) 
	#/ 4.4.- hybrid two phases
	hybridTwoPhases = testers.ClassHybridTwoPhasesTest()
	hybridTwoPhases.id = 'hybridTwoPhases'
	hybridTwoPhases.runner = hybridTwoPhases.setRunnerName('hybridTwoPhases.rn')
	hybridTwoPhases.obtainedResult = hybridTwoPhases.setOutputName('Kinetic_modelling_of_Amadori_degradation/')
	self.listOfTests.append(hybridTwoPhases)  
	#/ 4.5.- hybrid one phase
	hybridOnePhase = testers.ClassHybridOnePhaseTest()
	hybridOnePhase.id = 'hybridOnePhase'
	hybridOnePhase.runner = hybridOnePhase.setRunnerName('hybridOnePhase.rn')
	hybridOnePhase.obtainedResult = hybridOnePhase.setOutputName('')
	self.listOfTests.append(hybridOnePhase)  
	#/ 4.6.- special parameters of the optimisation
	#/ 4.6.1.- ga options: translocation rate and mutation rate
	gaOptions = testers.ClassGeneticAlgorithmTest()
	gaOptions.id = 'gaOptions'
	gaOptions.runner = gaOptions.setRunnerName('gaOptions.rn')
	gaOptions.obtainedResult = gaOptions.setOutputName('')
	self.listOfTests.append(gaOptions)
	#/ 4.6.2.- score stopper
	scoreStopper = testers.ClassScoreStopperTest()
	scoreStopper.id = 'scoreStopper'
	scoreStopper.runner = scoreStopper.setRunnerName('scoreStopper.rn')
	scoreStopper.obtainedResult = scoreStopper.setOutputName('Kinetic_modelling_of_Amadori_degradation/parametersFromLocalSearch/k10v10')
	self.listOfTests.append(scoreStopper)
	#/ 4.6.3.- numberOfSimulations stopper
	numberOfSimulationsStopper = testers.ClassNumberOfSimulationsStopperTest()
	numberOfSimulationsStopper.id = 'numberOfSimulationsStopper'
	numberOfSimulationsStopper.runner = numberOfSimulationsStopper.setRunnerName('numberOfSimulationsStopper.rn')
	numberOfSimulationsStopper.obtainedResult = numberOfSimulationsStopper.setOutputName('Kinetic_modelling_of_Amadori_degradation/parametersFromRandom/k10v10')
	self.listOfTests.append(numberOfSimulationsStopper) 
        #/ 5.- testing fitness function calculation
	fitnessFunctionCalculation = testers.ClassFitnessFunctionCalculationTest()
	fitnessFunctionCalculation.id = 'fitnessFunctionCalculation'
	fitnessFunctionCalculation.runner = fitnessFunctionCalculation.setRunnerName('fitnessFunctionCalculation.rn')
	fitnessFunctionCalculation.obtainedResult = fitnessFunctionCalculation.setOutputName('scratch/Kinetic_modelling_of_Amadori_degradation.log')
	self.listOfTests.append(fitnessFunctionCalculation)
        #/ 6.- testing trajectories reconstruction
	trajectoriesReconstruction = testers.ClassTrajectoriesReconstructionTest()
	trajectoriesReconstruction.id = 'trajectoriesReconstruction'
	trajectoriesReconstruction.runner = trajectoriesReconstruction.setRunnerName('trajectoriesReconstruction.rn')
	trajectoriesReconstruction.obtainedResult = trajectoriesReconstruction.setOutputName('')
	trajectoriesReconstruction.expectedResult = trajectoriesReconstruction.setResultName('')
	self.listOfTests.append(trajectoriesReconstruction)
        #/ 7.- testing fitness function surfaces
	surface = testers.ClassFitnessFunctionSurfaceTest()
	surface.id = 'surface'
	surface.runner = surface.setRunnerName('surface.rn')
	surface.obtainedResult = surface.setOutputName('k10v10.k2v2.')
	surface.expectedResult = surface.setResultName('k10v10.k2v2.txt')
	self.listOfTests.append(surface)	
        #/ 8.- testing sensitivity analysis
	sensitivity = testers.ClassSensitivityTest()
	sensitivity.id = 'sensitivity'
	sensitivity.runner = sensitivity.setRunnerName('sensitivity.rn')
	sensitivity.obtainedResult = sensitivity.setOutputName('')
	sensitivity.expectedResult = sensitivity.setResultName('')
	self.listOfTests.append(sensitivity)
	#/ 9.- identifiability analysis
	identifiability = testers.ClassIdentifiabilityTest()
	identifiability.id = 'identifiability'
	identifiability.runner = identifiability.setRunnerName('identifiability.rn')
	identifiability.obtainedResult = identifiability.setOutputName('')
	identifiability.expectedResult = identifiability.setResultName('')
	self.listOfTests.append(identifiability)
	#/ 10.- optimal experimental design
	oed = testers.ClassOEDTest()
	oed.id = 'oed'
	oed.runner = oed.setRunnerName('oed.rn')
	oed.obtainedResult = oed.setOutputName('')
	oed.expectedResult = oed.setResultName('')
	self.listOfTests.append(oed)
	#/ 11.- tests for tag format
	tagFormat = testers.ClassTagFormatTest()
	tagFormat.id = 'tagFormat'
	tagFormat.runner = tagFormat.setRunnerName('tagFormat.rn')
	tagFormat.expectedResult = tagFormat.setResultName('tagFormat.out')
	tagFormat.obtainedResult = tagFormat.setOutputName('')
	self.listOfTests.append(tagFormat)
	#/ 12.- tests for clustering
	if self.OctaveFound == True:
	    #/ 12.1.- for 2D
	    clustering2D = testers.ClassCluster2DTest()
	    clustering2D.id = 'clustering2D'
	    clustering2D.runner = clustering2D.setRunnerName('clustering2D.rn')
	    clustering2D.expectedResult = clustering2D.setResultName('')
	    clustering2D.obtainedResult = clustering2D.setOutputName('')
	    self.listOfTests.append(clustering2D)
	    #/ 12.2.- for 3D
	    clustering3D = testers.ClassCluster3DTest()
	    clustering3D.id = 'clustering3D'
	    clustering3D.runner = clustering3D.setRunnerName('clustering3D.rn')
	    clustering3D.expectedResult = clustering3D.setResultName('')
	    clustering3D.obtainedResult = clustering3D.setOutputName('')
	    self.listOfTests.append(clustering3D)

	return None

    def detector(self):
	
	'''
	This method detects if scipy, octave, xpp and openModelical are available on the current machine.
	'''
	
	print 'Detecting executables ...'
	scratchdir = os.environ.get('BYODYN_SCRATCH_DIR')
	#/ 1.- detecting scipy
	try:
	    import scipy
	    self.ScipyFound = True
	except:
	    self.ScipyFound = False
	#/ 2.- detecting octave
	octaveOutputMessagesFile = scratchdir + '/' + 'octaveOutputMessages'
	octaveErrorMessagesFile = scratchdir + '/' + 'octaveErrorMessages'
	os.system('octave -help 1> %s 2> %s'%(octaveOutputMessagesFile, octaveErrorMessagesFile))
	f = open(octaveOutputMessagesFile, 'r')
	lines = f.readlines()
	f.close()
	if len(lines) > 5: #/ this is completely arbitrary
	    vector = lines[0].split()
	    for i in range(len(vector)):
		if vector[i] == 'version':
		    version = vector[i+1]
	    versionNumber = version.split('.')
	    if int(versionNumber[0]) >= 3:
		self.OctaveFound = True
	    else:
		print 'It seems that an Octave executable is available, however its version is %s and version 3.0.1 or newer is required. Removing Octave runners from the test ...'%version
	#/ 3.- detecting xpp
	xppOutputMessagesFile = scratchdir + '/' + 'xppOutputMessages'
	xppErrorMessagesFile = scratchdir + '/' + 'xppErrorMessages'
	os.system('xppaut -help 1> %s 2> %s'%(xppOutputMessagesFile, xppErrorMessagesFile))
	f = open(xppOutputMessagesFile, 'r')
	lines = f.readlines()
	f.close()
	if len(lines) > 0: #/ this is completely arbitrary
	    self.XPPFound = True
	#/ 4.- detecting openModelica
	omcOutputMessagesFile = scratchdir + '/' + 'omcOutputMessages'
	omcErrorMessagesFile = scratchdir + '/' + 'omcErrorMessages'
	os.system('omc -help 1> %s 2> %s'%(omcOutputMessagesFile, omcErrorMessagesFile))
	f = open(omcOutputMessagesFile, 'r')
	lines = f.readlines()
	f.close()
	if len(lines) > 5: #/ this is completely arbitrary
	    self.OpenModelicaFound = True
	#/ 5.- printing the results
	print 'Executables found:',
	if self.ScipyFound == True:
	    print ' Scipy',
	if self.OctaveFound == True:
	    print ' Octave',
	if self.XPPFound == True:
	    print ' XPP',
	if self.OpenModelicaFound == True:
	    print ' OpenModelica',
	print '\nExecutables not found:',
	if self.ScipyFound == False:
	    print ' Scipy',
	if self.OctaveFound == False:
	    print ' Octave',
	if self.XPPFound == False:
	    print ' XPP',
	if self.OpenModelicaFound == False:
	    print ' OpenModelica',
	print

	return None

    def run(self):

	'''
	This method runs the available tests.
	'''
	
	print 'Collecting tests ...\t%s tests detected.'%len(self.listOfTests)
	i = 1
        for test in self.listOfTests:
            self.log[test.id] = test.run()
	    percentage = float(i)/float(len(self.listOfTests))*100
            print '\t\t\t\t... ' + self.log[test.id] + ' (%s'%str(int(percentage)) + ' %).'
	    i = i + 1
        summaryMessage = self.__writeLogFile()
        self.__printLog(summaryMessage)    

	return None
        
def main():

    '''
    This function calls the different tests available.
    '''

    byodynPath = os.environ.get('BYODYN_PATH')
    CARRY_ON = False
    predictedRunningTime = '2 minutes and 52 seconds'
    carryOn = raw_input('WARNING: The complete set of 57 tests take less than %s on a 2.4 GHz Intel Core 2 Duo CPU. Do you want to continue? (y/n) '%predictedRunningTime)
    if carryOn == 'y':
        #/ 1.- Starting counter time 
        initialTime =  time.time()
        print 'Testing started ...'  
	#/ 2.- Removing compiled sources
	print 'Removing compiled source files ...'
	benchmarkDir = byodynPath + '/benchmark'
	binDir = byodynPath + '/bin'
	libDir = byodynPath + '/lib'
	libStoch = byodynPath + '/lib/stochastic'
	srcDir = byodynPath + '/src'
	#/ 2.1.- appending files
	filesToRemove = []
	directoriesToRemove = [benchmarkDir, binDir, libDir, libStoch, srcDir]
	for directory in directoriesToRemove:
	    files = glob.glob(directory + '/*.pyc')
	    for file in files:
		try:
		    os.remove(file)
		except OSError:
		    raise errorMessages.ClassCheckerException, 'Error removing compiled source files. The problem might be related to the user permissions in the ByoDyn installation folder.'
    #/ 3.- Changing directory to testers directory
        userDir = os.getcwd()
        os.chdir('%s/benchmark'%byodynPath)
        #/ 4.- Initialising object and running the whole of tests
        tester = ClassChecker()
	tester.detector()
	tester.chooser()
        tester.run()  
        #/ 5.- Changing directory to user directory and finishing counter time
        os.chdir(userDir)
        lastTime = time.time()
        totalSecs = lastTime - initialTime
        minutes = int(totalSecs/60)
        secs = int(totalSecs - minutes*60)
        print 'Testing finished in %s minutes and %s seconds of CPU time.' %(minutes, secs)
    
    return None
